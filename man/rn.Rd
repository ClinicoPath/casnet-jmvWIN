% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/casnet_SOURCE_jamovi.R
\name{rn}
\alias{rn}
\title{Create a Recurrence Network Matrix}
\usage{
rn(y1, y2 = NULL, emDim = 1, emLag = 1, emRad = NULL,
  directed = FALSE, weighted = FALSE, weightedBy = c("si", "rt",
  "rf")[1], rescaleWeights = FALSE, fs = NA, includeDiagonal = FALSE,
  to.ts = NULL, order.by = NULL, to.sparse = FALSE,
  method = "Euclidean", targetValue = 0.05, returnGraph = FALSE,
  doPlot = FALSE, silent = TRUE, ...)
}
\arguments{
\item{y1}{A numeric vector or time series}

\item{y2}{A numeric vector or time series for cross recurrence}

\item{emDim}{The embedding dimensions}

\item{emLag}{The embedding lag}

\item{emRad}{The threshold (emRad) to apply to the distance matrix to create a binary matrix}

\item{directed}{Should the matrix be considered to represent a directed network? (default = `FALSE`)}

\item{weighted}{Should the matrix be considered to represent a weighted network? (default = `FALSE`)}

\item{weightedBy}{After setting values smaller than `emRad` to `0`, what should the recurrent values represent? The default is to use the state space similarity (distance/proximity) values as weights (`"si"`). Other option are `"rt"` for *recurrence time* and `"rf"` for *recurrence time frequency*, Because vertices represent time points in \eqn{\epsilon}-thresholded recurrence networks, a difference of two vertex-indices represents duration. If an edge `e1` connects `v1` and `v10` then the *recurrence time* will be the difference of the vertex indices, `9`, and the *recurrence time frequency* will be `1/9`.}

\item{rescaleWeights}{If set to `TRUE` and `weighted = TRUE`, all weight values will be rescaled to `[0,1]`, where `0` means no recurrence relation and `1` the maximum weight value.}

\item{fs}{Sample frequency: A numeric value interpreted as the `number of observed samples per unit of time`. If the weights represent recurrence times (`"rt"`), they will be divided by the value in `fs`. If the weights represent recurrence time frequencies (`"rf"`), they will be multiplied by the value of `fs` (default = `NA`)}

\item{includeDiagonal}{Should the diagonal of the matrix be included when creating the network (default = `FALSE`)}

\item{to.ts}{Should \code{y1} and \code{y2} be converted to time series objects?}

\item{order.by}{If \code{to.ts = TRUE}, pass a vector of the same length as \code{y1} and \code{y2}. It will be used as the time index, if \code{NA} the vector indices will be used to represent time.}

\item{to.sparse}{Should sparse matrices be used?}

\item{method}{Distance measure to use. Any option that is valid for argument \code{method} of \code{\link[proxy]{dist}}. Type \code{proxy::pr_DB$get_entries()} to se a list of all the options. Common methods are: "Euclidean", "Manhattan", "Minkowski", "Chebysev" (or the same but shorter: "L2","L1","Lp" and "max" distance) (default = \code{"Euclidean"})}

\item{returnGraph}{Return an [igraph::igraph()] object (default = `FALSE`)}

\item{doPlot}{Plot the matrix by calling \code{\link{rp_plot}} with defult settings}

\item{silent}{Silent-ish mode}

\item{...}{Any paramters to pass to [rn_plot()] if `doPlot = TRUE`}
}
\value{
A (Coss-) Recurrence matrix that can be interpreted as an adjacency (or incidence) matrix.
}
\description{
This function serves as a wrapper for function `rp()`, it will add some attributes to the matrix related to network representation. These attributes will be used to decide which network type to generate (e.g. undirected, directed, weighted, etc.)
}
\seealso{
Other Distance matrix operations (recurrence network): \code{\link{di2bi}},
  \code{\link{di2we}}, \code{\link{rn_plot}},
  \code{\link{rn_recSpec}}, \code{\link{rn_scaleoGram}}
}
\concept{Distance matrix operations (recurrence network)}
